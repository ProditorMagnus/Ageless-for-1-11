#textdomain wesnoth-Ageless_Era

# delete this?
#define AE_ARCHAIC_WEAPON_SPECIAL_VECTOR
    # dummy ability to be placed in
    # [specials] clause.
    [dummy]
        id=aa_vector_damage
        name= _ "vector damage"
        description=_"
..."
        #        multiply={DAMAGE}
        #        active_on=offense
    [/dummy]
#enddef
# hp = hp * 0.1 * [(victim level - attacker level + 1) * (-1,5) + 10]   &   there is 20% chance after hit that it works
#define AE_ARCHAIC_WEAPON_VECTOR DAMAGE NUMBER CHANCE
    [attack]
        name=khthon_vector
        description= _ "Vector"
        type=arcane
        range=ranged
        damage={DAMAGE}
        number={NUMBER}
        icon=attacks/magic-missile.png
        [specials]
            [chance_to_hit]
                id=khthon_vector
                name= _ "vector"
                description=_"
This attack always has a {CHANCE}% chance to hit regardless of the defensive ability of the unit being attacked.  If hit, susceptable opponents have 20% chance to become Khthon, attacker may lose health for attempt either way"
                value={CHANCE}
                cumulative=no
            [/chance_to_hit]
        [/specials]
        #		defense_weight=0
        # FAI might be able to handle this, but for now I should make default AI like this thing a bit more
        #		attack_weight=2.0
        # I'm changing this, so the take-over is still rare, but the arcane attack is useful against the undead , etc.
        [specials]
            {AE_ARCHAIC_WEAPON_SPECIAL_VECTOR}
            #	{WEAPON_SPECIAL_SWARM}
            #	    [chance_to_hit]
            #	        id=khthon_vector
            #	        name= _ "vector"
            #	        description=_"
            #This attack always has a 33% chance to hit regardless of the defensive ability of the unit being attacked.  If hit, susceptable opponents become Khthon."
            #	        value=33
            #	        cumulative=no
            #	    [/chance_to_hit]
        [/specials]
    [/attack]
    [attack_anim]
        [filter_attack]
            name=khthon_vector
        [/filter_attack]
        start_time=-500
        blend_color=50,190,220
        blend_ratio=0~0.3:150,0.3~0.6:150,0.6~1:150,1~0.3:150,0.3~0.0:75
        {MISSILE_FRAME_FAERIE_FIRE}
    [/attack_anim]
#enddef

#define AE_ARCHAIC_WEAPON_VECTOR_1
    {AE_ARCHAIC_WEAPON_VECTOR 9 1 15}
#enddef
#define AE_ARCHAIC_WEAPON_VECTOR_2
    {AE_ARCHAIC_WEAPON_VECTOR 16 1 25}
#enddef
#define AE_ARCHAIC_WEAPON_VECTOR_2p5
    {AE_ARCHAIC_WEAPON_VECTOR 12 2 25}
#enddef
#define AE_ARCHAIC_WEAPON_VECTOR_3
    {AE_ARCHAIC_WEAPON_VECTOR 22 1 30}
#enddef
#define AE_ARCHAIC_WEAPON_VECTOR_4
    {AE_ARCHAIC_WEAPON_VECTOR 30 1 35}
#enddef
#define AE_ARCHAIC_WEAPON_VECTOR_5
    {AE_ARCHAIC_WEAPON_VECTOR 40 1 40}
#enddef

#define AE_ARCHAIC_VECTOR_EVENTS

    # this makes the vector attack decrease as the unit gets wounded.  During the attack would be nice, but this will do for now
    # store the original attack value, so it can be restored when the unit heals
    [event]
        # recall would cause the unit to not be removed from the recall list,
        # so multiple copies of the same unit would be possible.  Why?
        name=recruit,recall,post_advance,prestart
        # fortunately, it did not seem necessary after all
        #	name=recruit,post_advance,prestart
        first_time_only=no
        # does this change anything?
        {VARIABLE unit_index_temp 0}
        [store_unit]
            [filter]
                has_weapon=khthon_vector
            [/filter]
            variable=khthon_adjust
            kill=yes
        [/store_unit]
        [while]
            [variable]
                name=unit_index_temp
                less_than=$khthon_adjust.length
            [/variable]
            [do]
                {LOOKUP_INDEX khthon_adjust[$unit_index_temp].attack name khthon_vector vector_index_temp}
                [if]
                    [variable]
                        name=khthon_adjust[$unit_index_temp].variables.original_vector
                        greater_than=$khthon_adjust[$unit_index_temp].attack[$vector_index_temp].damage
                    [/variable]
                    [else]
                        [set_variable]
                            name=khthon_adjust[$unit_index_temp].variables.original_vector
                            value=$khthon_adjust[$unit_index_temp].attack[$vector_index_temp].damage
                        [/set_variable]
                    [/else]
                [/if]
                [unstore_unit]
                    variable=khthon_adjust[$unit_index_temp]
                    find_vacant=no
                [/unstore_unit]
                [set_variable]
                    name=unit_index_temp
                    add=1
                [/set_variable]
            [/do]
        [/while]
        {CLEAR_VARIABLE unit_index_temp}
        {CLEAR_VARIABLE vector_index_temp}
        {CLEAR_VARIABLE khthon_adjust}
    [/event]

    # now the vector attack gets adjusted for unit health.  I think there are rounding errors.
    [event]
        name=turn refresh
        first_time_only=no
        [store_unit]
            [filter]
                has_weapon=khthon_vector
            [/filter]
            variable=khthon_adjust
            kill=yes
        [/store_unit]
        {VARIABLE unit_index_temp 0}
        [while]
            [variable]
                name=unit_index_temp
                less_than=$khthon_adjust.length
            [/variable]
            [do]
                {LOOKUP_INDEX khthon_adjust[$unit_index_temp].attack name khthon_vector vector_index_temp}
                [set_variable]
                    name=vector_value_temp
                    value=$khthon_adjust[$unit_index_temp].variables.original_vector
                [/set_variable]
                #	{DEBUG "1.- $khthon_adjust[$unit_index_temp].variables.original_vector"}
                #	{DEBUG "2.- $vector_value_temp"}
                [set_variable]
                    name=vector_value_temp
                    multiply=$khthon_adjust[$unit_index_temp].hitpoints
                [/set_variable]
                #	{DEBUG "3.- $vector_value_temp"}
                [set_variable]
                    name=vector_value_temp
                    divide=$khthon_adjust[$unit_index_temp].max_hitpoints
                [/set_variable]
                #	{DEBUG "4.- $unit_index_temp| - $vector_value_temp"}
                [set_variable]
                    name=khthon_adjust[$unit_index_temp].attack[$vector_index_temp].damage
                    value=$vector_value_temp
                [/set_variable]
                [unstore_unit]
                    variable=khthon_adjust[$unit_index_temp]
                    find_vacant=no
                [/unstore_unit]
                [set_variable]
                    name=unit_index_temp
                    add=1
                [/set_variable]
            [/do]
        [/while]
        {CLEAR_VARIABLE unit_index_temp}
        #	{CLEAR_VARIABLE vector_value_temp}
        {CLEAR_VARIABLE vector_index_temp}
        {CLEAR_VARIABLE khthon_adjust}
    [/event]

    # I don't know what will happen if the attack aborts because the victim was hit, so store_unit
    # at the beginning of attack, don't clear variable until attack_end.
    # this is not firing? - no it is firing, once for every khthon unit on the map, so clearing the variable breaks it
    # attack begins, set "vector_event_ended" to 0.  If attacker hits, set to 1 after first time, and event should not do anything after that.
    # similarly, after attack ends, set variable to 2 and the event should be silenced after first time.
    # Then, next time vector attack is used, variable is set to 0 and we start over.  Basically, all [event]s need to depend upon the "vector_event_ended"
    # so they fire (1), (2), (3) and not (1)X(# of khthon), (2)X(# of khthon), (3)X(# of khthon).
    [event]
        name=attack
        first_time_only=no
        [filter_attack]
            name=khthon_vector
        [/filter_attack]
        [store_unit]
            [filter]
                x,y=$x1,$y1
            [/filter]
            variable=attacker_temp
            kill=no
        [/store_unit]
        [store_unit]
            [filter]
                x,y=$x2,$y2
            [/filter]
            variable=victim_temp
            kill=no
        [/store_unit]
        [set_variable]
            name=vector_event_ended
            value=0
        [/set_variable]
        #	[message]
        #	speaker=narrator
        #	message= _ "Fired! $victim_temp.level"
        #	[/message]
        # OK, so it fires
    [/event]

    [event]
        # it doesn't matter if the attack was successful, attacker pays for it
        name=attack_end
        first_time_only=no
        [filter_attack]
            name=khthon_vector
        [/filter_attack]
        #	[message]
        #	speaker=narrator
        #	message= _ "Fired! $victim_temp.level"
        #	[/message]
        #	It fires multiple times, so ...
        [if]
            [variable]
                name=vector_event_ended
                less_than=2
            [/variable]
            # this should stop the event from firing if the unit dies?
            [and]
                [have_unit]
                    x,y=$x1,$y1
                [/have_unit]
            [/and]
            [then]
                # store the attacker again, so defender attacks are not negated
                [store_unit]
                    [filter]
                        x,y=$x1,$y1
                    [/filter]
                    variable=attacker_temp
                    kill=yes
                [/store_unit]
                # find the difference between attacker and defender levels
                [set_variable]
                    name=damage_attacker
                    value=$victim_temp.level
                [/set_variable]
                [set_variable]
                    name=damage_attacker
                    sub=$attacker_temp.level
                [/set_variable]
                # we don't want to heal the attacker
                [if]
                    [variable]
                        name=damage_attacker
                        less_than=0
                    [/variable]
                    [then]
                        [set_variable]
                            name=damage_attacker
                            value=0
                        [/set_variable]
                    [/then]
                [/if]
                [set_variable]
                    name=damage_attacker_vis
                    value=$attacker_temp.hitpoints
                [/set_variable]
                [set_variable]
                    name=damage_attacker
                    add=1
                [/set_variable]
                [set_variable]
                    name=damage_attacker
                    # this might need to be adjusted
                    multiply=-1.5
                [/set_variable]
                # converting it to how much attacker has left
                [set_variable]
                    name=damage_attacker
                    add=10
                [/set_variable]
                [set_variable]
                    name=attacker_temp.hitpoints
                    multiply=$damage_attacker
                [/set_variable]
                [set_variable]
                    name=attacker_temp.hitpoints
                    multiply=0.1
                [/set_variable]
                [set_variable]
                    name=damage_attacker_vis
                    sub=$attacker_temp.hitpoints
                [/set_variable]
                [set_variable]
                    name=damage_attacker_vis
                    round=0
                [/set_variable]
                [unstore_unit]
                    variable=attacker_temp
                    red,green,blue=255,0,0
                    text= _ "$damage_attacker_vis"
                [/unstore_unit]
                {CLEAR_VARIABLE damage_attacker}
                {CLEAR_VARIABLE damage_attacker_vis}
                {CLEAR_VARIABLE victim_temp}
                {CLEAR_VARIABLE attacker_temp}
                # so this event only gets fired once, no matter how many khthon are on the map
                [set_variable]
                    name=vector_event_ended
                    value=2
                [/set_variable]
            [/then]
        [/if]
    [/event]

    [event]
        name=attacker_hits
        first_time_only=no
        [filter_second]
            [not]
                race=AE primeval
            [/not]
            [not]
                race=undead
            [/not]
            [not]
                race=AE phantom_egypt
            [/not]
            [not]
                race=AE phantom_spirit
            [/not]
            [not]
                race=AE despair
            [/not]
            [not]
                race=AE despair_wisp
            [/not]
            [not]
                race=mechanical
            [/not]
            [not]
                race=AE khthon
            [/not]
            [not]
                canrecruit=yes
            [/not]
        [/filter_second]
        [filter_attack]
            name=khthon_vector
        [/filter_attack]
        [set_variable]
            name=vector_chance_temp
            rand=1..5
            # for testing
            #		rand=1..2
        [/set_variable]
        [if]
            # so it only gets fired once
            [variable]
                name=vector_event_ended
                less_than=1
            [/variable]
            [and]
                [variable]
                    name=vector_chance_temp
                    numerical_equals=1
                [/variable]
            [/and]
            [then]
                [set_variable]
                    name=victim_temp.race
                    value=AE lesser_khthon
                [/set_variable]
                [set_variable]
                    name=victim_temp.side
                    value=$attacker_temp.side
                [/set_variable]
                [set_variable]
                    name=victim_temp.alignment
                    value=chaotic
                [/set_variable]
                [set_variable]
                    name=victim_temp.hitpoints
                    value=$victim_temp.max_hitpoints
                [/set_variable]
                [set_variable]
                    name=victim_temp.moves
                    value=0
                [/set_variable]
                [kill]
                    x,y=$x2,$y2
                [/kill]
                [unstore_unit]
                    variable=victim_temp
                    red,green,blue=0,200,150
                    text= _ "Possessed"
                [/unstore_unit]
                # this should use the KHTHONIZED macro
                [object]
                    silent=yes
                    duration=forever
                    [filter]
                        x,y=$x2,$y2
                    [/filter]
                    [effect]
                        apply_to=attack
                        range=melee
                        increase_damage=20%
                    [/effect]
                    [effect]
                        apply_to=resistance
                        replace=false
                        [resistance]
                            cold=-30
                            arcane=30
                        [/resistance]
                    [/effect]
                    [effect]
                        apply_to=hitpoints
                        increase_total=-25%
                        full_heal=yes
                    [/effect]
                    [effect]
                        apply_to=image_mod
                        replace="CS(-100,-25,-22)"
                    [/effect]
                [/object]
                [set_variable]
                    name=vector_event_ended
                    value=1
                [/set_variable]
            [/then]
        [/if]
    [/event]

    [event]
        # this is to make sure the khthon stuff doesn't go away when the unit advances
        name=advance
        first_time_only=no
        [filter]
            race=AE lesser_khthon
        [/filter]
        # It should be OK to store just this one unit, because the next event should always fire afterward
        [store_unit]
            [filter]
                x,y=$x1,$y1
            [/filter]
            variable=advancer_temp
            kill=no
        [/store_unit]
    [/event]
    [event]
        name=post advance
        first_time_only=no
        [filter]
            side=$advancer_temp.side
        [/filter]
        [store_unit]
            [filter]
                x,y=$x1,$y1
            [/filter]
            variable=post_advancer_temp
            kill=no
        [/store_unit]
        [if]
            [variable]
                name=post_advancer_temp.id
                equals=$advancer_temp.id
            [/variable]
            [then]
                [kill]
                    x,y=$x1,$y1
                [/kill]
                [set_variable]
                    name=post_advancer_temp.race
                    value=AE lesser_khthon
                [/set_variable]
                [set_variable]
                    name=post_advancer_temp.alignment
                    value=chaotic
                [/set_variable]
                [unstore_unit]
                    variable=post_advancer_temp
                [/unstore_unit]
                {CLEAR_VARIABLE advancer_temp}
                {CLEAR_VARIABLE post_advancer_temp}
            [/then]
        [/if]
    [/event]
#enddef
